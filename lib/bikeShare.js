// Generated by CoffeeScript 1.8.0
(function() {
  var async, config, db, feeds, getCities, getCity, host, mongo, open, port, prepareResources, remapData, remapErrors, remapLatLong, remapProperty, run, saveAllStations, server, translateData, update, updateFeeds, updateStations, utils, _ref;

  async = require('async');

  mongo = require('mongodb');

  utils = require('./utils');

  feeds = require('./feeds.json');

  config = require('./config.json');

  _ref = config.mongo, host = _ref.host, port = _ref.port;

  server = new mongo.Server(host, port, {
    auto_reconnect: true
  });

  db = new mongo.Db('BikeShare', server, {
    journal: true
  });

  open = function(next) {
    return db.open(function(err, db) {
      if (err) {
        return next(err);
      }
      return next(null, db);
    });
  };

  prepareResources = function(db, done) {
    return async.waterfall([
      function(next) {
        return db.collection('feeds').find({}, next);
      }, function(data, next) {
        return data.toArray(next);
      }
    ], function(err, cities) {
      var type, url, urls;
      urls = (function() {
        var _i, _len, _ref1, _results;
        _results = [];
        for (_i = 0, _len = cities.length; _i < _len; _i++) {
          _ref1 = cities[_i], url = _ref1.url, type = _ref1.type;
          _results.push({
            url: url,
            type: type
          });
        }
        return _results;
      })();
      return done(err, urls);
    });
  };

  remapErrors = function(station) {
    var locked, statusKey, statusValue;
    statusKey = station.statusKey, statusValue = station.statusValue, locked = station.locked;
    switch (locked) {
      case 'true':
        station.statusKey = config.statusKey.notInService;
        station.statusValue = 'Not In Service';
        break;
      case 'false':
        station.statusKey = config.statusKey.inService;
        station.statusValue = 'In Service';
    }
    delete station.locked;
    return station;
  };

  remapLatLong = function(station) {
    var coordinates, prop, properties, _i, _len;
    properties = ['lat', 'longitude', 'latitude', 'long'];
    coordinates = {};
    coordinates.latitude = parseFloat(station.lat || station.latitude);
    coordinates.longitude = parseFloat(station.long || station.longitude);
    for (_i = 0, _len = properties.length; _i < _len; _i++) {
      prop = properties[_i];
      if (station[prop]) {
        delete station[prop];
      }
    }
    station.coordinates = coordinates;
    station.id = coordinates.latitude + coordinates.latitude;
    return station;
  };

  remapProperty = function(station, primary, secondary) {
    var value;
    if (primary === 'name') {
      station[primary] = station[primary] || station[secondary];
    } else {
      value = station[primary] || station[secondary];
      value = parseInt(value || 0);
      station[primary] = value;
    }
    if (secondary) {
      delete station[secondary];
    }
    return station;
  };

  remapData = function(station, done) {
    var field, _i, _len, _ref1;
    station = remapErrors(station);
    station = remapLatLong(station);
    station = remapProperty(station, 'availableBikes', 'nbBikes');
    station = remapProperty(station, 'availableDocks', 'nbEmptyDocks');
    station = remapProperty(station, 'name', 'stationName');
    station.totalDocks = station.availableDocks + station.availableBikes;
    _ref1 = utils.unused_fields;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      field = _ref1[_i];
      delete station[field];
    }
    return done(null, station);
  };

  translateData = function(stations, next) {
    return async.map(stations, remapData, next);
  };

  update = function(db, collection, query, update, next) {
    var options;
    collection = db.collection(collection);
    options = {
      safe: true,
      upsert: true
    };
    return collection.update(query, update, options, next);
  };

  updateFeeds = function(db, done) {
    return async.eachSeries(feeds, (function(feed, next) {
      var query;
      query = {
        id: feed.id
      };
      return update(db, 'feeds', query, feed, next);
    }), done);
  };

  updateFeeds = function(db, done) {
    return async.eachSeries(feeds, (function(feed, next) {
      var query;
      query = {
        id: feed.id
      };
      return update(db, 'feeds', query, feed, next);
    }), done);
  };

  saveAllStations = function(db, stations, done) {
    return async.eachSeries(stations, (function(station, next) {
      var query;
      query = {
        name: station.name
      };
      return update(db, 'stations', query, station, next);
    }), done);
  };

  getCities = function(endpoints, next) {
    return async.concat(endpoints, getCity, next);
  };

  getCity = function(endpoint, next) {
    var url;
    url = endpoint.url;
    return utils.get(url, next);
  };

  updateStations = function(db, done) {
    var resources;
    resources = [];
    return async.waterfall([
      function(next) {
        return prepareResources(db, next);
      }, function(endpoints, next) {
        return getCities(endpoints, next);
      }, function(stations, next) {
        return translateData(stations, next);
      }, function(stations, next) {
        return saveAllStations(db, stations, next);
      }
    ], function(err) {
      return done(err);
    });
  };

  run = function() {
    return async.waterfall([
      function(next) {
        return open(next);
      }, function(db, next) {
        return async.series([
          function(next) {
            return updateFeeds(db, next);
          }, function(next) {
            return updateStations(db, next);
          }
        ], function(err) {
          var log, time;
          time = Date.now();
          log = {
            err: err,
            time: time
          };
          return update(db, 'logs', log, log, next);
        });
      }
    ], function(err) {
      if (err) {
        return console.log("Error: " + err);
      }
    });
  };

  run();

  module.exports = {
    allStations: function(req, res) {
      var stations;
      stations = db.collection('stations');
      return async.waterfall([
        function(next) {
          return stations.find({}, next);
        }, function(results, next) {
          return results.toArray(next);
        }
      ], function(err, stations) {
        if (err) {
          return res.send('Database error');
        }
        return res.send(stations);
      });
    }
  };

}).call(this);
